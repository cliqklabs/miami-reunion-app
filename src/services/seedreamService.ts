import { fal } from "@fal-ai/client";

const FAL_API_KEY = import.meta.env.VITE_FAL_API_KEY;

if (!FAL_API_KEY) {
  throw new Error("VITE_FAL_API_KEY environment variable is not set");
}

// Configure fal client
// NOTE: In production, consider using a backend proxy to keep API keys secure
// For now, this is acceptable for development/testing purposes
fal.config({
  credentials: FAL_API_KEY,
});

// Rate limiting state
let lastRequestTime = 0;
const MIN_REQUEST_INTERVAL = 2000; // 2 seconds between requests
const pendingRequests = new Set<string>();

/**
 * Uploads an image data URL to Fal.ai storage and returns the uploaded URL
 * @param imageDataUrl The data URL of the image
 * @returns Promise that resolves to the uploaded image URL
 */
async function uploadImageToFal(imageDataUrl: string): Promise<string> {
  try {
    console.log("Converting data URL to blob...");
    // Convert data URL to blob
    const response = await fetch(imageDataUrl);
    const blob = await response.blob();
    console.log("Blob created, size:", blob.size, "type:", blob.type);
    
    console.log("Uploading to Fal.ai storage...");
    // Upload to Fal.ai storage
    const uploadResult = await fal.storage.upload(blob);
    console.log("Upload successful, URL:", uploadResult);
    return uploadResult;
  } catch (error) {
    console.error("Failed to upload image to Fal.ai:", error);
    console.error("Error details:", error);
    throw new Error(`Failed to upload reference image: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Interface for Seedream 4.0 generation result
 */
interface SeedreamResult {
  images: Array<{
    url: string;
    width?: number;
    height?: number;
    content_type?: string;
    file_size?: number;
  }>;
  seed: number;
}

/**
 * Generates an image using Seedream 4.0 Edit via Fal.ai (image-to-image)
 * @param imageDataUrl The reference image data URL to use as input
 * @param prompt The text prompt for image editing
 * @param requestId Optional unique identifier for this request
 * @returns Promise that resolves to a base64-encoded image data URL
 */
export async function generateSeedreamImage(
  imageDataUrl: string,
  prompt: string, 
  requestId?: string
): Promise<string> {
  // Prevent duplicate requests
  if (requestId && pendingRequests.has(requestId)) {
    throw new Error('Request already in progress');
  }
  
  if (requestId) {
    pendingRequests.add(requestId);
  }

  try {
    // Rate limiting
    const now = Date.now();
    const timeSinceLastRequest = now - lastRequestTime;
    if (timeSinceLastRequest < MIN_REQUEST_INTERVAL) {
      const waitTime = MIN_REQUEST_INTERVAL - timeSinceLastRequest;
      console.log(`Rate limiting: waiting ${waitTime}ms before next request`);
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
    lastRequestTime = Date.now();

    console.log("Generating image with Seedream 4.0 Edit...");
    
    // First, upload the reference image to Fal.ai storage
    // NOTE: This upload step might be causing the slowdown. Consider using text-to-image instead
    const uploadStartTime = Date.now();
    let imageUrl: string;
    try {
      imageUrl = await uploadImageToFal(imageDataUrl);
      const uploadTime = Date.now() - uploadStartTime;
      console.log(`Upload completed in ${uploadTime}ms, URL:`, imageUrl);
    } catch (uploadError) {
      const uploadTime = Date.now() - uploadStartTime;
      console.warn(`Upload failed after ${uploadTime}ms, trying alternative approach:`, uploadError);
      // Fallback: try using the data URL directly (some endpoints might support it)
      imageUrl = imageDataUrl;
      console.log("Using data URL directly:", imageUrl);
    }
    
    const generationStartTime = Date.now();
    console.log("Starting Seedream generation...");
    const result = await fal.subscribe("fal-ai/bytedance/seedream/v4/edit", {
      input: {
        prompt: prompt,
        image_urls: [imageUrl],
        image_size: "square_hd", // Use predefined size for faster processing
        num_images: 1,
        enable_safety_checker: false, // Disable for faster generation
        sync_mode: true // Use sync mode for faster response
      },
      logs: true,
      onQueueUpdate: (update) => {
        if (update.status === "IN_PROGRESS") {
          console.log("Seedream edit generation in progress...");
          update.logs?.map((log) => log.message).forEach(console.log);
        }
      },
    }) as { data: SeedreamResult };

    const generationTime = Date.now() - generationStartTime;
    console.log(`Seedream generation completed in ${generationTime}ms`);

    if (!result.data.images || result.data.images.length === 0) {
      throw new Error("No images generated by Seedream 4.0 Edit");
    }

    // Download the image and convert to base64
    const generatedImageUrl = result.data.images[0].url;
    const response = await fetch(generatedImageUrl);
    
    if (!response.ok) {
      throw new Error(`Failed to download generated image: ${response.statusText}`);
    }

    const blob = await response.blob();
    
    // Convert blob to base64 using FileReader to avoid stack overflow
    const base64 = await new Promise<string>((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const result = reader.result as string;
        // Remove the data URL prefix to get just the base64 part
        const base64Data = result.split(',')[1];
        resolve(base64Data);
      };
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
    
    const mimeType = blob.type || 'image/jpeg';
    return `data:${mimeType};base64,${base64}`;

  } catch (error) {
    console.error("Seedream generation error:", error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Seedream generation failed: ${errorMessage}`);
  } finally {
    if (requestId) {
      pendingRequests.delete(requestId);
    }
  }
}

/**
 * Fallback prompts for when original prompts might be too specific
 */
export function getSeedreamFallbackPrompt(styleName: string): string {
  const stylePrompts: Record<string, string> = {
    // Miami fallbacks - more general descriptions
    "Drug Lord": "Portrait of a confident businessman in an expensive white suit with gold accessories, luxury Miami setting, professional photography",
    "Strip Club Owner": "Portrait of a flashy entrepreneur in silk clothing with gold jewelry, neon lighting, Miami nightlife aesthetic",
    "Cocaine Cowboy": "Portrait in 1980s Miami Vice style with pastel clothing and aviator sunglasses, retro aesthetic",
    "Sugar Daddy": "Portrait of a sophisticated gentleman in designer clothing, luxury oceanfront setting, confident pose",
    "Beach Gigolo": "Portrait of a man in casual beach attire with sunglasses, tropical Miami backdrop, relaxed pose",
    
    // Ibiza fallbacks
    "Selfie Influencer": "Portrait of a stylish person with trendy outfit and accessories, luxury pool backdrop, social media aesthetic",
    "Club Siren": "Portrait of a fashionable person in party attire, vibrant nightclub lighting, energetic vibe",
    "Boho Hippie": "Portrait in bohemian style with flowing clothes and natural accessories, beach sunset setting",
    "Wannabe Shaman": "Portrait in spiritual style with natural clothing, peaceful outdoor meditation setting",
    "Lost Tourist": "Portrait of a traveler in casual vacation clothes, Mediterranean island backdrop",
    "Party Bro": "Portrait of an energetic person in casual beach party attire, festival lighting",
    "DJ Wannabe": "Portrait of a music enthusiast with headphones and trendy outfit, electronic music backdrop",
    "Yacht Playboy": "Portrait in luxury casual wear, boat marina backdrop, confident lifestyle pose",
    "Spiritual Dude": "Portrait in relaxed meditation style, comfortable natural clothing, peaceful setting",
    "Rave Veteran": "Portrait of a music festival enthusiast in party attire, concert lighting backdrop"
  };

  return stylePrompts[styleName] || `Professional portrait in ${styleName} style, high quality photography`;
}

/**
 * Generates an image using Seedream 4.0 Text-to-Image (faster, no reference image)
 * @param prompt The text prompt for image generation
 * @param requestId Optional unique identifier for this request
 * @returns Promise that resolves to a base64-encoded image data URL
 */
export async function generateSeedreamTextToImage(
  prompt: string, 
  requestId?: string
): Promise<string> {
  // Prevent duplicate requests
  if (requestId && pendingRequests.has(requestId)) {
    throw new Error('Request already in progress');
  }
  
  if (requestId) {
    pendingRequests.add(requestId);
  }

  try {
    // Rate limiting
    const now = Date.now();
    const timeSinceLastRequest = now - lastRequestTime;
    if (timeSinceLastRequest < MIN_REQUEST_INTERVAL) {
      const waitTime = MIN_REQUEST_INTERVAL - timeSinceLastRequest;
      console.log(`Rate limiting: waiting ${waitTime}ms before next request`);
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
    lastRequestTime = Date.now();

    console.log("Generating image with Seedream 4.0 Text-to-Image (fast mode)...");
    
    const generationStartTime = Date.now();
    const result = await fal.subscribe("fal-ai/bytedance/seedream/v4/text-to-image", {
      input: {
        prompt: prompt,
        image_size: "square_hd", // Use predefined size for faster processing
        num_images: 1,
        enable_safety_checker: false, // Disable for faster generation
        sync_mode: true // Use sync mode for faster response
      },
      logs: true,
      onQueueUpdate: (update) => {
        if (update.status === "IN_PROGRESS") {
          console.log("Seedream text-to-image generation in progress...");
          update.logs?.map((log) => log.message).forEach(console.log);
        }
      },
    }) as { data: SeedreamResult };

    const generationTime = Date.now() - generationStartTime;
    console.log(`Seedream text-to-image generation completed in ${generationTime}ms`);

    if (!result.data.images || result.data.images.length === 0) {
      throw new Error("No images generated by Seedream 4.0 Text-to-Image");
    }

    // Download the image and convert to base64
    const generatedImageUrl = result.data.images[0].url;
    const response = await fetch(generatedImageUrl);
    
    if (!response.ok) {
      throw new Error(`Failed to download generated image: ${response.statusText}`);
    }

    const blob = await response.blob();
    
    // Convert blob to base64 using FileReader to avoid stack overflow
    const base64 = await new Promise<string>((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const result = reader.result as string;
        // Remove the data URL prefix to get just the base64 part
        const base64Data = result.split(',')[1];
        resolve(base64Data);
      };
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
    
    const mimeType = blob.type || 'image/jpeg';
    return `data:${mimeType};base64,${base64}`;

  } catch (error) {
    console.error("Seedream text-to-image generation error:", error);
    const errorMessage = error instanceof Error ? error.message : String(error);
    throw new Error(`Seedream text-to-image generation failed: ${errorMessage}`);
  } finally {
    if (requestId) {
      pendingRequests.delete(requestId);
    }
  }
}
